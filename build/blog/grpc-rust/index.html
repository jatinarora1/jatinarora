<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.61">
<title data-react-helmet="true">A beginners guide to gRPC with Rust | Jatin Arora</title><meta data-react-helmet="true" property="og:title" content="A beginners guide to gRPC with Rust | Jatin Arora"><meta data-react-helmet="true" name="description" content="Table of Contents"><meta data-react-helmet="true" property="og:description" content="Table of Contents"><meta data-react-helmet="true" property="og:image" content="http://localhost:3000/img/jatin.jpg"><meta data-react-helmet="true" property="twitter:image" content="http://localhost:3000/img/jatin.jpg"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for A beginners guide to gRPC with Rust | Jatin Arora"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link data-react-helmet="true" rel="shortcut icon" href="/img/jatin.jpg"><link rel="stylesheet" href="/styles.d48d5b3b.css">
<link rel="preload" href="/styles.152560a6.js" as="script">
<link rel="preload" href="/runtime~main.b8677e71.js" as="script">
<link rel="preload" href="/main.48060fb2.js" as="script">
<link rel="preload" href="/1.57e2cf85.js" as="script">
<link rel="preload" href="/2.818658f0.js" as="script">
<link rel="preload" href="/3.d3fc3d6d.js" as="script">
<link rel="preload" href="/ccc49370.2475dd98.js" as="script">
<link rel="preload" href="/1abd5052.9756626d.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">Jatin Arora</strong></a><a class="navbar__item navbar__link" href="/resume">Resume</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/projects">Conributions</a><a href="https://github.com/jatinarora1" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">Jatin Arora</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/resume">Resume</a></li><li class="menu__list-item"><a class="menu__link" href="/projects">Conributions</a></li><li class="menu__list-item"><a href="https://github.com/jatinarora1" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--8 col--offset-2"><article><header><h1 class="margin-bottom--sm blogPostTitle_1mse">A beginners guide to gRPC with Rust</h1><div class="margin-vert--md"><time datetime="2020-04-24T00:00:00.000Z" class="blogPostDate_3bQP">April 24, 2020  Â· 20 min read</time></div><div class="avatar margin-vert--md"><a class="avatar__photo-link avatar__photo" href="https://github.com/anshulrgoyal" target="_blank" rel="noreferrer noopener"><img src="/img/anshul.jpg" alt="Anshul Goyal"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noreferrer noopener">Anshul Goyal</a></h4><small class="avatar__subtitle"></small></div></div></header><section class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="table-of-contents"></a>Table of Contents<a aria-hidden="true" tabindex="-1" class="hash-link" href="#table-of-contents" title="Direct link to heading">#</a></h1><ol><li>Introduction</li><li>Protocol Buffer</li><li>Rust and gRPC</li><li>Creating a Server</li><li>Creating a Client</li><li>Streaming in gRPC</li><li>Authentication</li><li>Conclusion</li></ol><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="introduction"></a>Introduction<a aria-hidden="true" tabindex="-1" class="hash-link" href="#introduction" title="Direct link to heading">#</a></h1><p>HTTP and JSON is a very popular method for creating web APIs. HTTP and JSON make sense because it uses a very popular protocol. HTTP and JSON are text-based protocol which causes a performance problem since serializing JSON is a slow process, most HTTP and JSON or Rest APIs do not support streaming which means we cannot start processing the data before it arrives. Rest APIs have very good tooling and community support. Almost every programming language has a high-quality implementation for HTTP and serializing JSON. Rest architecture doesnâ€™t fit every use case, it is difficult to provide client library for Rest APIs for every language and maintain these libraries. Since there is no language-independent method for defining the structure of JSON and HTTP requests, therefore, it is difficult to generate client libraries. gRPC is an attempt to tackle these problems.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="brief-intro-to-grpc"></a>Brief Intro to gRPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#brief-intro-to-grpc" title="Direct link to heading">#</a></h2><p>gRPC is an open-source remote procedure call system developed by Google. gRPC allows the system to communicate in and out of data centers, efficiently transferring data from mobile, IoT devices, backends to one and other. gRPC came with plug able support for load balancing, authentication, tracing, etc. gRPC supports bidirectional streaming over HTTP/2. gRPC provides an idiomatic implementation in 10 languages. gRPC can generate efficient client libraries and uses the protocol buffer format for transferring data over the wire. Protocol buffers are a binary format for data transmission. Since protocol buffers are a binary protocol, it can be serialized fast and the structure of each message must be predefined.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="a-little-about-rust"></a>A Little about Rust<a aria-hidden="true" tabindex="-1" class="hash-link" href="#a-little-about-rust" title="Direct link to heading">#</a></h2><p>Rust is a systems programming language. Rust provides high level ergonomic with low-level control. Rust provides control over memory management without the hassle associated with it. Rust has good support for Asynchronous operation making it a good fit for writing networking applications. Rust has zero cost abstraction making it blazing fast.</p><p><img src="https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587676359774_grpc-2.png" alt="Work Flow Source(https://blog.logrocket.com/creating-a-crud-api-with-node-express-and-grpc/)"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="protocol-buffers"></a>Protocol Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#protocol-buffers" title="Direct link to heading">#</a></h1><p>Protocol buffers are extensible, language-neutral data serializing mechanism. It is fast, small, and simple. Protocol buffers have a predefined structure with its syntax for defining messages and services. Services are functions that can be executed and messages are arguments passed to the function and values returned by these functions. There are two versions of protocol buffers. This tutorial would use version 3.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="syntax"></a>Syntax<a aria-hidden="true" tabindex="-1" class="hash-link" href="#syntax" title="Direct link to heading">#</a></h2><p>Protocol Buffers have a very simple syntax. There are two things to be defined in a protocol buffer.</p><ul><li><code>service</code> It defines all the functionality that can be called on a particular service or server.</li><li><code>message</code> It defines arguments and returns values of an <code>RPC</code> call.</li></ul><p>The <code>syntax</code> and <code>package</code> must be defined in every protocol buffer file. Protocol buffer files are saved with <code>.proto</code> extension.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-proto codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    // version of protocol buffer used</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    syntax = &quot;proto3&quot;;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // package name for the buffer will be used later</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    package hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // service which can be executed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    service Say {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // function which can be called</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc Send (SayRequest) returns (SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // argument</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    message SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // data type and position of data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      string name = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // return value</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    message SayResponse {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // data type and position of data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      string message = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>A service is defined by using <code>service</code> keyword then defining call using <code>rpc</code> keyword, <code>send</code> is the name of the call, it can be used to make a call, <code>SayRequest</code> define the argument <code>send</code> call takes and <code>SayResponse</code> defines the value returned by the call. Any number of the call can be defined in service.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-proto codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    service Say {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // function which can be called</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc Send (SayRequest) returns (SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc Take (SayRequest) returns (SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><em>Implementation of these function is not defined in the</em> <code>*.proto*</code> <em>file, these implementations are provided by the server</em></p><p><strong>Assign Number to Fields</strong>
The number assigned to a field is very important because it is used to recognize the field in binary data. It takes 1 byte to encode 0-15 numbers and 2 bytes for encoding 16-2047, it is wise to use 0-15 for frequently occurring data. It is also recommended to reserve a few numbers so that, these reserved numbers can be used later if some changes are made to format.</p><p><strong>Different Data Types</strong></p><p>Prototype support many data types include string, int, float, boolean, etc. These types can be repeated using <code>repeated</code> field attributes.</p><p>Protocol buffer syntax is explained in great detail in <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener noreferrer">official documentation.</a></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="rust-and-grpc"></a>Rust and gRPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#rust-and-grpc" title="Direct link to heading">#</a></h1><p>Rust ecosystem has grown quite big with very good quality crates. <code>tonic</code> is very performant gRPC implementation for Rust. This tutorial uses <code>tonic</code> as the gRPC implementation and <code>tonic-build</code> for compiling <code>.proto</code> files to client libraries.
Let us start by creating a new cargo project using <code>cargo init</code>. Now we need to create an add a few dependencies and build dependencies. These will help us with our server and client.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-toml codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    [package]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    name = &quot;grpc&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    version = &quot;0.1.0&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    authors = [&quot;Anshul Goyal &lt;anshulgoel151999@gmail.com&gt;&quot;]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    edition = &quot;2018&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    [dependencies]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    prost = &quot;0.6.1&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    tonic = {version=&quot;0.2.0&quot;,features = [&quot;tls&quot;]}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    tokio = {version=&quot;0.2.18&quot;,features = [&quot;stream&quot;, &quot;macros&quot;]}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    futures = &quot;0.3&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    [build-dependencies]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    tonic-build = &quot;0.2.0&quot;</span></div></div></div></div></div><p>This should be a configuration for <code>Cargo.toml</code> file. <code>prost</code> provides basic types for gRPC, <code>tokio</code> provide asynchronous runtime and <code>futures</code> for handling asynchronous streams.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="compiling-protocol-buffers"></a>Compiling Protocol Buffers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#compiling-protocol-buffers" title="Direct link to heading">#</a></h2><p>We would use <code>build.rs</code> for compiling our <code>.proto</code> files and include then in binary. <code>tonic-build</code> crate provides a method <code>compile_protos</code> which take the path to <code>.ptoto</code> file and compile it to rust definitions. First, we create a folder in the root directory named <code>proto</code> it will contain all of out <code>.proto</code> files. We create a <code>say.proto</code> file in this directory. With our <code>Say</code> service shown in the above example.</p><p>We create a <code>build.rs</code> with the following code.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    fn main()-&gt;Result&lt;(),Box&lt;dyn std::error::Error&gt;&gt;{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // compiling protos using path on build time</span></div><div class="token-line" style="color:#393A34"><span class="token plain">       tonic_build::compile_protos(&quot;proto/say.proto&quot;)?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">       Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>The above code will compile <code>proto/say.proto</code> file and save it in an <code>OUT_DIR</code> and add an environment variable <code>OUT_DIR</code> which is available at build time so that we can use it later in our code. We can also provide different options for compiling the protocol buffers. Now your directory structure should look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    â”œâ”€â”€ build.rs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â”œâ”€â”€ Cargo.lock</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â”œâ”€â”€ Cargo.toml</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â”œâ”€â”€ proto</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â”‚   â””â”€â”€ say.proto</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â”œâ”€â”€ src</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        â”œâ”€â”€ main.rs</span></div></div></div></div></div><p>Now we have compiled our <code>.proto</code> files we would use it in our code using <code>tonic</code> utility. We would create a module for our server and client. Let us name it <code>hell.rs</code> and we would add the following code.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    // this would include code generated for package hello from .proto file</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    tonic::include_proto!(&quot;hello&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div></div></div></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="creating-a-server"></a>Creating a Server<a aria-hidden="true" tabindex="-1" class="hash-link" href="#creating-a-server" title="Direct link to heading">#</a></h1><p>Now we have compiled the protocol buffers we are ready to build our server. We have to provide the implementation for every service and <code>rpc</code> we defined. Service would be defined as traits and <code>rpc</code> would be a member function on these traits. Since Rust doesn&#x27;t support async traits we have to use an <code>asyc_trait</code> macro for overcoming this limitation. We create a file named <code>server.rs</code> and add the following code.</p><p><code>**tonic-build**</code> <strong>would automatically compile</strong> <code>**.proto**</code> <strong>following rust naming conventions and best practices.</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use tonic::{transport::Server, Request, Response, Status};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_server::{Say, SayServer};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::{SayResponse, SayRequest};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // defining a struct for our service</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Default)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub struct MySay {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // implementing rpc for service defined in .proto</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tonic::async_trait]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    impl Say for MySay {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // our rpc impelemented as function</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        async fn send(&amp;self,request:Request&lt;SayRequest&gt;)-&gt;Result&lt;Response&lt;SayResponse&gt;,Status&gt;{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // returning a response as SayResponse message as defined in .proto</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(Response::new(SayResponse{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // reading data from request which is awrapper around our SayRequest message defined in .proto</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                 message:format!(&quot;hello {}&quot;,request.get_ref().name),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // defining address for our service</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let addr = &quot;[::1]:50051&quot;.parse().unwrap();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a service</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let say = MySay::default();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Server listening on {}&quot;, addr);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // adding our service to our server.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Server::builder()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .add_service(SayServer::new(say))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .serve(addr)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>In Rust, messages are represented as structs and services as traits and RPC as functions. We <code>impl</code> the trait for our struct and pass it to our server. In our example, we would create a send function which takes <code>Request</code> as an argument which contains details about the request and wraps our message <code>SayRequest</code> which can be accessed using <code>.get_ref</code> method. Now let us run this by adding a bin block to our <code>Cargo.toml</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-toml codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    [[bin]]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    name = &quot;server&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    path = &quot;src/server.rs&quot;</span></div></div></div></div></div><p>This will help us testing and maintaining code in save repo but it is not suggested for a large project.
Now if we run this with command <code>cargo run</code> <code>--``bin server</code>. We can see our server running at <code>127:0:0:1:50051</code>.</p><p><img src="https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587642193283_image.png" alt="Example"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="creating-a-client"></a>Creating a Client<a aria-hidden="true" tabindex="-1" class="hash-link" href="#creating-a-client" title="Direct link to heading">#</a></h1><p>Our server is ready, now let&#x27;s test it by creating a client. Since we have compiled our protocol buffer we can import our <code>hello.rs</code> file and use it. We create a <code>client.rs</code> file and add the following code.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_client::SayClient;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::SayRequest;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a channel ie connection to server</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let channel = tonic::transport::Channel::from_static(&quot;http://[::1]:50051&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        .connect()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating gRPC client from channel</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut client = SayClient::new(channel);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a new Request</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let request = tonic::Request::new(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">               name:String::from(&quot;anshul&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // sending request and waiting for response</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let response = client.send(request).await?.into_inner();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;RESPONSE={:?}&quot;, response);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>We add a bin key to our <code>Cargo.toml</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-toml codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    [[bin]]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    name = &quot;client&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    path = &quot;src/client.rs&quot;</span></div></div></div></div></div><p>We create a channel that is an HTTP/2 connection that can be used then from our client. HTTP/2 support streams that can be used by gRPC. Now if we run our client with command <code>cargo run</code> <code>--bin client</code> we can see see the response.</p><p><img src="https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587643536436_image.png"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="error-handling"></a>Error Handling<a aria-hidden="true" tabindex="-1" class="hash-link" href="#error-handling" title="Direct link to heading">#</a></h1><p>Error handling in gRPC is done using Status. <code>tonic</code> provide <code>Status</code> enum which can be returned in case of error with appropriate error message.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    Err(Status::unauthenticated(&quot;Token not found&quot;))</span></div></div></div></div></div><p>gRPC support bare-bone error handling but you can extend yourself using protocol buffer here is <a href="https://cloud.google.com/apis/design/errors#error_model" target="_blank" rel="noopener noreferrer">detail explanation</a></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streaming-in-grpc"></a>Streaming In gRPC<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streaming-in-grpc" title="Direct link to heading">#</a></h1><p>HTTP/2 supports streaming and gRPC provides a nice interface for using it. We can start sending the response even before the client finish sends the request. We can use it to provide an efficient service. The server has not to wait for the request from the client to complete the request. We need to make a few changes to our protocol buffers so that it reflects that we support streaming. We need to make changes to our rust code also. Rust has quite good support for asynchronous I/O. We would <code>tokio</code> to stream response and request.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streaming-response"></a>Streaming Response<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streaming-response" title="Direct link to heading">#</a></h2><p>We would start by the streaming server since most of the time server would be sending a large amount of data. We would use a queue for sending data by multiplexing different task on a single thread. <code>tokio</code> provide very excellent multi sender single receiver channel.</p><p><strong>Changes to protocol buffers</strong></p><p>We change the code of protocol buffer to the following. We use a stream keyword in <code>rpc</code> and specify that the <code>rpc</code> call will return a stream of messages <code>SayResponse</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    service Say {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // function which can be called</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc Send (SayRequest) returns (SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // we specify that we return a stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc SendStream(SayRequest) returns (stream SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><strong>Changes to Server Code</strong>
We would use <code>tokio::sync::mpsc</code> for communicating between futures. We send multiple responses using this channel. We would use <code>tokio::spawn</code> to create a new task that can be then scheduled. We add the following code to our <code>server.rs</code> file.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use tokio::sync::mpsc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use tonic::{transport::Server, Request, Response, Status};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_server::{Say, SayServer};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::{SayRequest, SayResponse};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Default)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub struct MySay {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tonic::async_trait]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    impl Say for MySay {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // Specify the output of rpc call</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        type SendStreamStream=mpsc::Receiver&lt;Result&lt;SayResponse,Status&gt;&gt;;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // implementation for rpc call</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        async fn send_stream(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            &amp;self,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            request: Request&lt;SayRequest&gt;,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ) -&gt; Result&lt;Response&lt;Self::SendStreamStream&gt;, Status&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a queue or channel</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let (mut tx, rx) = mpsc::channel(4);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a new task</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            tokio::spawn(async move {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // looping and sending our response using stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                for _ in 0..4{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // sending response to our channel</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    tx.send(Ok(SayResponse {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        message: format!(&quot;hello&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    .await;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            });</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // returning our reciever so that tonic can listen on reciever and send the response to client</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(Response::new(rx))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        async fn send(&amp;self, request: Request&lt;SayRequest&gt;) -&gt; Result&lt;Response&lt;SayResponse&gt;, Status&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(Response::new(SayResponse {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                message: format!(&quot;hello {}&quot;, request.get_ref().name),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let addr = &quot;[::1]:50051&quot;.parse().unwrap();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let say = MySay::default();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Server listening on {}&quot;, addr);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Server::builder()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .add_service(SayServer::new(say))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .serve(addr)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>We need to change the main function, we just add a new function to trait and a type to specify our output. In this new <code>send_stream</code> function we create a channel so that we can send a response and return the receiver. The receiver implements the<code>Stream</code> trait so it can be streamed by HTTP/2 and the sender can be used by multiple threads and it implements <code>Sink</code> trait. We have created a bounded channel but we can also use an unbounded channel.</p><p><strong>Changes in Client Code</strong>
We need to make changes to response handling. Since it would be a stream now, we would just listen to this stream and print the response. Streams help to write non-blocking code and use resources more efficiently.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_client::SayClient;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::SayRequest;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let channel = tonic::transport::Channel::from_static(&quot;http://[::1]:50051&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        .connect()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut client = SayClient::new(channel);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let request = tonic::Request::new(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">               name:String::from(&quot;anshul&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // now the response is stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut response = client.send_stream(request).await?.into_inner();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // listening to stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while let Some(res) = response.message().await? {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;NOTE = {:?}&quot;, res);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="streaming-request"></a>Streaming Request<a aria-hidden="true" tabindex="-1" class="hash-link" href="#streaming-request" title="Direct link to heading">#</a></h2><p>Sometimes all the data is not available, for example in a game all the data is not available then it would make stream the data and send all the data available and sending rest when available. This allows using data more efficiently on user devices. We need a few changes to our code.</p><p><strong>Changes to protocol buffer</strong>
We would use the <code>stream</code> keyword to specify the argument is a stream. We would use <code>stream</code> to specify that our <code>rpc</code> takes a stream as an argument.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    // service which can be executed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    service Say {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // function which can be called</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc Send (SayRequest) returns (SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc SendStream(SayRequest) returns (stream SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // taking a stream as response</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc ReceiveStream(stream SayRequest) returns (SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><strong>Changes to Server</strong>
We need our server to accept the stream as the request. We would listen on the stream and collect. Then we would respond when the stream finishes. It will save our resources since we can wait on stream asynchronously.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use tokio::sync::mpsc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use tonic::{transport::Server, Request, Response, Status};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_server::{Say, SayServer};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::{SayRequest, SayResponse};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Default)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub struct MySay {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tonic::async_trait]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    impl Say for MySay {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // .. rest of rpcs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // create a new rpc to receive a stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        async fn receive_stream(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            &amp;self,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            request: Request&lt;tonic::Streaming&lt;SayRequest&gt;&gt;,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ) -&gt; Result&lt;Response&lt;SayResponse&gt;, Status&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // converting request into stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let mut stream = request.into_inner();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let mut message = String::from(&quot;&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // listening on stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            while let Some(req) = stream.message().await? {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                message.push_str(&amp;format!(&quot;Hello {}\n&quot;, req.name))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // returning response</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(Response::new(SayResponse { message }))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let addr = &quot;[::1]:50051&quot;.parse().unwrap();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let say = MySay::default();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Server listening on {}&quot;, addr);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Server::builder()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .add_service(SayServer::new(say))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .serve(addr)tes());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><strong>Changes to Client</strong>
We would now program our client to send a stream to our server. For this, we would mimic a stream using <code>futures</code> crate and create a stream from a vector.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use futures::stream::iter;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_client::SayClient;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::SayRequest;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let channel = tonic::transport::Channel::from_static(&quot;http://[::1]:50051&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .connect()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut client = SayClient::new(channel);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let request = tonic::Request::new(iter(vec![</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;anshul&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;rahul&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;vijay&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ]));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // sending stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let response = client.receive_stream(request).await?.into_inner();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;RESPONSE=\n{}&quot;, response.message);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><img src="https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587657121220_image.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="bidirectional-stream"></a>Bidirectional Stream<a aria-hidden="true" tabindex="-1" class="hash-link" href="#bidirectional-stream" title="Direct link to heading">#</a></h2><p>The bidirectional stream is also supported by gRPC. The bidirectional stream is just a combination of streaming requests and streaming responses. Here is a quick example.</p><p><strong>Protocol buffer</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // version of protocol buffer used</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    syntax = &quot;proto3&quot;;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // package name for buffer will be used later</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    package hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // service which can be executed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    service Say {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // takes a stream and returns a stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      rpc Bidirectional(stream SayRequest) returns (stream SayResponse);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // argument</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    message SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // data type and position of data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      string name = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // return value</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    message SayResponse {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // data type and position of data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      string message = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><strong>Sever</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use tokio::sync::mpsc;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use tonic::{transport::Server, Request, Response, Status};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_server::{Say, SayServer};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::{SayRequest, SayResponse};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Default)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub struct MySay {}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tonic::async_trait]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    impl Say for MySay {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // defining return stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        type BidirectionalStream = mpsc::Receiver&lt;Result&lt;SayResponse, Status&gt;&gt;;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        async fn bidirectional(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            &amp;self,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            request: Request&lt;tonic::Streaming&lt;SayRequest&gt;&gt;,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ) -&gt; Result&lt;Response&lt;Self::BidirectionalStream&gt;, Status&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // converting request in stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let mut streamer = request.into_inner();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating queue</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let (mut tx, rx) = mpsc::channel(4);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            tokio::spawn(async move {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // listening on request stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                while let Some(req) = streamer.message().await.unwrap(){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // sending data as soon it is available</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    tx.send(Ok(SayResponse {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        message: format!(&quot;hello {}&quot;, req.name),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    .await;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            });</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // returning stream as receiver</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(Response::new(rx))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let addr = &quot;[::1]:50051&quot;.parse().unwrap();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let say = MySay::default();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Server listening on {}&quot;, addr);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Server::builder()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .add_service(SayServer::new(say))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .serve(addr)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><strong>Client</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use futures::stream::iter;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::say_client::SayClient;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use hello::SayRequest;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    mod hello;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[tokio::main]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let channel = tonic::transport::Channel::from_static(&quot;http://[::1]:50051&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .connect()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut client = SayClient::new(channel);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating a client</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let request = tonic::Request::new(iter(vec![</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;anshul&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;rahul&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            SayRequest {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;vijay&quot;),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        ]));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // calling rpc</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut response = client.bidirectional(request).await?.into_inner();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // listening on the response stream</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        while let Some(res) = response.message().await? {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;NOTE = {:?}&quot;, res);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p><img src="https://paper-attachments.dropbox.com/s_59BE9A5DB3EFBE4D28334D77611F2324BC09BD447D8DEAD39CC6417F47CAB169_1587658480089_image.png" alt="Example"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="authentication"></a>Authentication<a aria-hidden="true" tabindex="-1" class="hash-link" href="#authentication" title="Direct link to heading">#</a></h1><p>Authentication is a very important aspect of a system. gRPC comes with plug able authentication support. gRPC support mainly two types of authentication:</p><ul><li>Token-based authentication</li><li>TLS based authentication</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="token-based-authentication"></a>Token-Based Authentication<a aria-hidden="true" tabindex="-1" class="hash-link" href="#token-based-authentication" title="Direct link to heading">#</a></h2><p>In this tutorial, we would use JWT based authentication. JWT or JSON web token provides an open-source and stateless authentication mechanism. We would <code>jsonwebtoken</code> crate for creating JWT and validating it. We would just see how we can use JWT with gRPC.</p><p><strong>Server</strong>
We would need to add an interceptor, that would validate token, if the token is not valid, we would just close the request, if the token is valid then we forward the request to our handlers.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    fn interceptor(req:Request&lt;()&gt;)-&gt;Result&lt;Request&lt;()&gt;,Status&gt;{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let token=match req.metadata().get(&quot;authorization&quot;){</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Some(token)=&gt;token.to_str(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            None=&gt;return Err(Status::unauthenticated(&quot;Token not found&quot;))</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        };</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // do some validation with token here ...</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(req)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>If we return <code>Ok</code> then the request would be passed on to functions but if we return <code>Err</code> with status the request is closed with provided status. We create a service with this interceptor.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    let say = MySay::default();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let ser = SayServer::with_interceptor(say,interceptor);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    Server::builder().add_service(ser).serve(addr).await?;</span></div></div></div></div></div><p><strong>Client</strong>
We need to add an interceptor to our client also. We would add it to our main function as a closure.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">        let channel = tonic::transport::Channel::from_static(&quot;http://[::1]:50051&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .connect()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let token = get_token();// an method to get token can be a rpc call etc.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut client = SayClient::with_interceptor(channel, move |mut req: Request&lt;()&gt;| {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // adding token to request.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            req.metadata_mut().insert(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                &quot;authorization&quot;,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tonic::metadata::MetadataValue::from_str(&amp;token).unwrap(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(req)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        });</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="mutual-tls-based-authentication"></a>Mutual TLS Based Authentication<a aria-hidden="true" tabindex="-1" class="hash-link" href="#mutual-tls-based-authentication" title="Direct link to heading">#</a></h2><p>TLS stands for Transport Layer Security, it is recommended by gRPC documentation to encrypt HTTP/2 connection with TLS. We would TLS to authenticate both client and server. This is called Mutual TLS. We would create a private key and public key for both client and server. We would also create a Certificate Authority certificate so that we can sign our TLS certificate. We would require OpenSSL for creating certificates.</p><p><strong>Creating Certificates</strong></p><p>OpenSSL is a command-line utility for creating keys and encryption-related stuff. We would start by creating a Certification Authority certificate.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">openssl genrsa -des3 -out my_ca.key 2048</span></div></div></div></div></div><p>This would act as our signing key. We would use it to sign our TLS certificate. Next, we create our certificate which is called the root CA certificate. It is used to validate if our TLS certificate is
validated or not.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">openssl req -x509 -new -nodes -key my_ca.key -sha256 -days 1825 -out my_ca.pem</span></div></div></div></div></div><p>This command would ask you a few questions. Details enter in this doesnâ€™t matter. If you can get this certificate on every device on earth you become a certificate signing authority like Letâ€™s Encrypt etc. Now let&#x27;s create our server key and certificate.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">openssL genrsa -out server.key 2048</span></div></div></div></div></div><p>This command will generate a key for our server. Now we create a certificate signing request for our key.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">openssl req -new -sha256 -key server.key -out server.csr</span></div></div></div></div></div><p>This would ask you some questions. Now we create a <code>server.ext</code> file. This file would contain our name, our domain, or subdomain.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">authorityKeyIdentifier=keyid,issuer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">basicConstraints=CA:FALSE</span></div><div class="token-line" style="color:#393A34"><span class="token plain">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span></div><div class="token-line" style="color:#393A34"><span class="token plain">subjectAltName = @alt_names</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">[alt_names]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">DNS.1 = localhost</span></div></div></div></div></div><p>We add our identity in the form of DNS. Now we run the following command</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">openssl x509 -req -in server.csr -CA my_ca.pem -CAkey my_ca.key -CAcreateserial -out server.pem -days 1825 -sha256 -extfile server.ext</span></div></div></div></div></div><p>You donâ€™t need to provide your private key or server key. This might ask you a few questions and passcode provided when generating the Certificate Authority key.
You can generate a Certificate for the client using the same certificate authority. Now we have all the required certificates to let configure our server and client.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="configuring-client-and-server"></a>Configuring Client and Server<a aria-hidden="true" tabindex="-1" class="hash-link" href="#configuring-client-and-server" title="Direct link to heading">#</a></h2><p><code>tonic</code> support TLS using <code>rust-tls</code>. We can configure TLS by following the method.</p><p>This shows how to configure the client for TLS.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">        // getting certificate from disk</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let cert=include_str!(&quot;../client.pem&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let key=include_str!(&quot;../client.key&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // creating identify from key and certificate</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let id=tonic::transport::Identity::from_pem(cert.as_bytes(),key.as_bytes());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // importing our certificate for CA</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let s=include_str!(&quot;../my_ca.pem&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // converting it into a certificate</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let ca=tonic::transport::Certificate::from_pem(s.as_bytes());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // telling our client what is the identity of our server</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let tls=tonic::transport::ClientTlsConfig::new().domain_name(&quot;localhost&quot;).identity(id).ca_certificate(ca);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // connecting with tls</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let channel = tonic::transport::Channel::from_static(&quot;http://[::1]:50051&quot;)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .tls_config(tls)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .connect()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div></div></div></div></div><p>This shows how to configure for TLS.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">        let say = MySay::default();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // reading cert and key disk</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let cert = include_str!(&quot;../server.pem&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let key = include_str!(&quot;../server.key&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating identity from cert and key</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let id = tonic::transport::Identity::from_pem(cert.as_bytes(), key.as_bytes());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // reading ca root from disk</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let s = include_str!(&quot;../my_ca.pem&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating certificate</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let ca = tonic::transport::Certificate::from_pem(s.as_bytes());</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating tls config</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let tls = tonic::transport::ServerTlsConfig::new()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .identity(id)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .client_ca_root(ca);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    // creating server with tls</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Server::builder()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .tls_config(tls)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .add_service(ser)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .serve(addr)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            .await?;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div></div></div></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="conclusion"></a>Conclusion<a aria-hidden="true" tabindex="-1" class="hash-link" href="#conclusion" title="Direct link to heading">#</a></h1><p>We have gone through basic protocol buffer and gRPC. We have created our server. We also created a client for interacting with the server. We learned how to compile our <code>.proto</code> file in rust client. We also learned how to stream responses and requests. We also created a bidirectional stream. We learned two different authentication strategy. We implemented JWT and Mutual TLS based authentication. Now you have a basic understanding of gRPC, you can create your own micro-service based app. gRPC comes with support for load-balancing,tracing and health tracking. Now you can explore further functionality of gRPC.</p></section><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/rust">rust</a><a class="margin-horiz--sm" href="/blog/tags/grpc">grpc</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/strapi"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Â« All in one guide for creating a killer API with Strapi</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/nodejs-rust-match"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Rust and Node.js: A match made in heaven Â»</div></a></div></nav></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">About</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/resume">Resume</a></li><li class="footer__item"><a class="footer__link-item" href="/projects">Contributions</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://dev.to/jatinarora1" target="_blank" rel="noopener noreferrer" class="footer__link-item">Dev.to</a></li><li class="footer__item"><a href="https://medium.com/@arora8331" target="_blank" rel="noopener noreferrer" class="footer__link-item">Medium</a></li><li class="footer__item"><a href="https://www.linkedin.com/in/jatin-a-5a3286137/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Linkedin</a></li><li class="footer__item"><a href="https://twitter.com/JATINAR27664823" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright Â© 2020 Jatin Arora.</div></div></div></footer></div>
<script src="/styles.152560a6.js"></script>
<script src="/runtime~main.b8677e71.js"></script>
<script src="/main.48060fb2.js"></script>
<script src="/1.57e2cf85.js"></script>
<script src="/2.818658f0.js"></script>
<script src="/3.d3fc3d6d.js"></script>
<script src="/ccc49370.2475dd98.js"></script>
<script src="/1abd5052.9756626d.js"></script>
</body>
</html>