<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.61">
<title data-react-helmet="true">Rust and Node.js: A match made in heaven | Jatin Arora</title><meta data-react-helmet="true" property="og:title" content="Rust and Node.js: A match made in heaven | Jatin Arora"><meta data-react-helmet="true" name="description" content="Table of Contents"><meta data-react-helmet="true" property="og:description" content="Table of Contents"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:image" content="https://paper-attachments.dropbox.com/s_3C11437A61A671DE930509E35F223D4A57F95F8B98F2408BFA72EA39228306E2_1587462711550_Untitled+design.png"><meta data-react-helmet="true" property="twitter:image" content="https://paper-attachments.dropbox.com/s_3C11437A61A671DE930509E35F223D4A57F95F8B98F2408BFA72EA39228306E2_1587462711550_Untitled+design.png"><meta data-react-helmet="true" name="twitter:image:alt" content="Image for Rust and Node.js: A match made in heaven"><link data-react-helmet="true" rel="shortcut icon" href="/img/jatin.jpg"><link rel="stylesheet" href="/styles.d48d5b3b.css">
<link rel="preload" href="/styles.152560a6.js" as="script">
<link rel="preload" href="/runtime~main.b8677e71.js" as="script">
<link rel="preload" href="/main.48060fb2.js" as="script">
<link rel="preload" href="/1.57e2cf85.js" as="script">
<link rel="preload" href="/2.818658f0.js" as="script">
<link rel="preload" href="/3.d3fc3d6d.js" as="script">
<link rel="preload" href="/ccc49370.2475dd98.js" as="script">
<link rel="preload" href="/13288dd4.611b1975.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">Jatin Arora</strong></a><a class="navbar__item navbar__link" href="/resume">Resume</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/projects">Conributions</a><a href="https://github.com/jatinarora1" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">Jatin Arora</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/resume">Resume</a></li><li class="menu__list-item"><a class="menu__link" href="/projects">Conributions</a></li><li class="menu__list-item"><a href="https://github.com/jatinarora1" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--8 col--offset-2"><article><header><h1 class="margin-bottom--sm blogPostTitle_1mse">Rust and Node.js: A match made in heaven</h1><div class="margin-vert--md"><time datetime="2020-04-19T00:00:00.000Z" class="blogPostDate_3bQP">April 19, 2020  Â· 21 min read</time></div><div class="avatar margin-vert--md"><a class="avatar__photo-link avatar__photo" href="https://github.com/anshulrgoyal" target="_blank" rel="noreferrer noopener"><img src="/img/anshul.jpg" alt="Anshul Goyal"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noreferrer noopener">Anshul Goyal</a></h4><small class="avatar__subtitle"></small></div></div></header><section class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="table-of-contents"></a>Table of Contents<a aria-hidden="true" tabindex="-1" class="hash-link" href="#table-of-contents" title="Direct link to heading">#</a></h2><ol><li>Available Methods</li><li>Native Addons</li><li>Setting Of Project</li><li>A deep dive in Napi</li><li>Conclusion</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="this-article-was-published-at-log-rocket"></a>This article was published at <a href="https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/" target="_blank" rel="noopener noreferrer">Log Rocket</a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#this-article-was-published-at-log-rocket" title="Direct link to heading">#</a></h3><p>Node.js is a very popular JavaScript runtime for writing backend applications. Its flexibility and nonblocking nature have made it the premier choice for API consumption.</p><p>Since it is a scripting language, JavaScript can be pretty slow. But thanks to V8 optimization, it is fast enough for practical applications. That said, Node.js is not good for heavy lifting; since itâ€™s single-threaded, it is dangerous to block the main thread for doing long calculations. Thatâ€™s where <a href="https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/" target="_blank" rel="noopener noreferrer">worker</a> <a href="https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/" target="_blank" rel="noopener noreferrer"></a><a href="https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/" target="_blank" rel="noopener noreferrer">threads</a> come in. Node.js has support for worker threads, so it can be used to perform long calculations.</p><p>As great as worker threads are, JavaScript is still slow. Moreover, worker thread are not available in all supported LTS versions of Node. Fortunately, we can use Rust to build a native add-on for Node.js. FFI is another alternative, but itâ€™s slower than the add-on approach. Rust is blazing fast and has fearless concurrency. Since Rust has a very small runtime (or &quot;not runtime&quot;), our binary size should also be pretty small.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="what-is-rust"></a>What is Rust?<a aria-hidden="true" tabindex="-1" class="hash-link" href="#what-is-rust" title="Direct link to heading">#</a></h2><p>Rust is a systems programming language by Mozilla. It can call the C library by default and includes first-class support for exporting functions to C.</p><p>Rust provides you with low-level control and high-level ergonomics. It gives you control of memory management without the hassle associated with these controls. It also delivers zero-cost abstraction, so you pay for only what you use.</p><p>Rust can be called in a Node.js context via various methods. Iâ€™ve listed some of the most widely used below.</p><ul><li>You can use FFI from Node.js and Rust, but this is very slow</li><li>You can use WebAssembly to create a <code>node_module</code>, but all Node.js functionality is not available</li><li>You can use native addons</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="what-is-a-native-addon"></a>What is a native addon?<a aria-hidden="true" tabindex="-1" class="hash-link" href="#what-is-a-native-addon" title="Direct link to heading">#</a></h2><p>Node.js addons are shared objects written in C++ that are dynamically linked. You can load them into Node.js using the <code>require()</code> function and use them as if they were ordinary Node.js modules. They primarily provide an interface between JavaScript running in Node.js and C/C++ libraries.</p><p>A native addon provides a simple interface to work with another binary by loading it in V8 runtime. It is very fast and safe for making calls across the languages. Currently, Node.js supports two types of addon methods: C++ addons and N-API C++/C addons.</p><p><strong>C++ Addons</strong></p><p>A C++ addon is an object that can be mounted by Node.js and used in the runtime. Since C++ is a compiled language, these addons are very fast. C++ has a wide array of production-ready libraries that can be used to expand the Node.js ecosystem. Many popular libraries use native addons to improve performance and code quality.</p><p><strong>N-API</strong> <strong>C++/C Addons</strong></p><p>The main problem with C++ addons is that you need to compile them again with every change to underlying JavaScript runtime. It causes a problem with maintaining the addon. N-API tries to eliminate this, by introducing a standard ABI (Application Binary Interface). The C header file remains backward compatible. That means the addon compiled for a particular version of Node.js, can be used with any version greater than the version of Node.js it was compiled for. You would use this method to implement your addon.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="where-does-rust-come-in"></a>Where does Rust come in?<a aria-hidden="true" tabindex="-1" class="hash-link" href="#where-does-rust-come-in" title="Direct link to heading">#</a></h2><p>Rust can mimic the behavior of a C library. In other words, it exports the function in a format the C can understand and use. Rust calls the C function to access and use APIs provided by the Node.js. These APIs provide methods for creating JavaScript strings, arrays, numbers, error, objects, functions, and more. But we need to tell Rust what these external functions, structs, pointers, etc. look like.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">#[repr(C)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">struct MyRustStruct {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    a: i32,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">extern &quot;C&quot; fn rust_world_callback(target: *mut RustObject, a: i32) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Function is called from C world&quot;, a);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        // Do something on rust struct</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (*target).a = a;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">extern {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   fn register_callback(target: *mut MyRustStruct,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        cb: extern fn(*mut MyRustStruct, i32)) -&gt; i32;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   fn trigger_callback();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p>Rust lays down the structs in memory differently, so we need to tell it to use the style C uses. It would a pain to create these functions by hand, so weâ€™ll use a crate called <code>nodejs-sys</code> that uses <code>bindgen</code> to create a nice definition for N-API.</p><p><code>b``indgen</code> automatically generates Rust FFI bindings to C and C++ libraries.</p><p>Note: There will a lot of unsafe code ahead, mostly external function calls.</p><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/4rgbnohg8ly3hb5g1vac.gif" alt="Joker"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="setting-up-your-project"></a>Setting up your project<a aria-hidden="true" tabindex="-1" class="hash-link" href="#setting-up-your-project" title="Direct link to heading">#</a></h2><p>For this tutorial, you must have <a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a> and <a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer">Rust</a> installed on your system, with <a href="https://github.com/rust-lang/cargo/" target="_blank" rel="noopener noreferrer">Cargo</a> and <a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer">NPM</a>. I would suggest using <a href="https://rustup.rs/" target="_blank" rel="noopener noreferrer">Rustup</a> to install Rust and <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener noreferrer">nvm</a> for Node.js.</p><p>Create a directory named <code>rust-addon</code> and initialize a new npm project by running <code>npm init</code>. Next, init a cargo project called <code>cargo init --lib</code>. Your project directory should look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ Cargo.toml</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ package.json</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â””â”€â”€ src</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â””â”€â”€ lib.rs</span></div></div></div></div></div><p><strong>Configuring Rust to compile to the addon</strong></p><p>We need Rust to compile to a dynamic C library or object. Configure cargo to compile to the <code>.so</code> file on Linux, <code>.dylib</code> on OS X, and <code>.dll</code> on Windows. Rust can produce many different types of libraries using Rustc flags or Cargo.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">[package]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">name = &quot;rust-addon&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">version = &quot;0.1.0&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">authors = [&quot;Anshul Goyal &lt;anshulgoel151999@gmail.com&gt;&quot;]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">edition = &quot;2018&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">[lib]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">crate-type=[&quot;cdylib&quot;]</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">nodejs-sys = &quot;0.2.0&quot;</span></div></div></div></div></div><p>The <code>lib</code> key provides options to configure Rustc. The <code>name</code> key gives the library name to the shared object in the form of <code>lib{name}</code>, while <code>type</code> provides the type of library it should be compiled to â€” e.g., <code>cdylib</code>, <code>rlib</code>, etc. <code>cdylib</code> creates a dynamically linked C library. This shared object behaves like a C library.</p><p><strong>Starting with</strong> <strong>N-API</strong></p><p>Letâ€™s create our N-API library. We need to add a dependency. <code>nodejs-sys</code> provides us with the binding required for <code>napi-header</code> files. <code>napi_register_module_v1</code> is the entry point for the addon. <a href="https://nodejs.org/api/n-api.html#n_api_module_registration" target="_blank" rel="noopener noreferrer">N</a><a href="https://nodejs.org/api/n-api.html#n_api_module_registration" target="_blank" rel="noopener noreferrer">-</a><a href="https://nodejs.org/api/n-api.html#n_api_module_registration" target="_blank" rel="noopener noreferrer">API documentation</a> recommends <code>N-API``_MODULE_INIT</code> macro for module registration which compiles to <code>napi_register_module_v1</code> function.</p><p>Node.js calls this function and provides it with an opaque pointer called <code>napi_env</code>, which refers to the configuration of the module in JavaScript runtime, and <code>napi_value</code>. The latter is another opaque pointer that represents a JavaScript value, which, in reality is an object known as an export. These exports are the same as those the <code>require</code> function provides to the Node.js modules in JavaScript.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">use nodejs_sys::{napi_create_string_utf8, napi_env, napi_set_named_property, napi_value};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">use std::ffi::CString;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">#[no_mangle]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn napi_register_module_v1(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    env: napi_env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports: napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">) -&gt; nodejs_sys::napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a C string</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let key = CString::new(&quot;hello&quot;).expect(&quot;CString::new failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a memory location where the pointer to napi_value will be saved</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a C string</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let value = CString::new(&quot;world!&quot;).expect(&quot;CString::new failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating napi_value for the string</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_string_utf8(env, value.as_ptr(), 6, &amp;mut local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// setting the string on the exports object</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_set_named_property(env, exports, key.as_ptr(), local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// returning the object</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p>Rust represents owned strings with the <code>S``tring</code> type and borrowed slices of strings with the <code>str</code> primitive. Both are always in UTF-8 encoding and may contain null bytes in the middle. If you look at the bytes that make up the string, there may be a <code>\0</code> among them. Both <code>String</code> and <code>str</code> store their length explicitly; there are no null terminators at the end of strings like C strings.</p><p>Rust strings are very different from the ones in C, so we need to change our Rust strings to C strings before we can use then with N-API functions. Since exports is an object represented by <code>exports</code>, we can add functions, strings, arrays, or any other JavaScript objects as key-value pairs.</p><p>To add a key to a JavaScript object, you can use a method provided by the N-API <code>napi_set_named_property</code>. This function takes the object to which we want to add a property; a pointer to a string that will be used as the key for our property; the pointer to the JavaScript value, which can be a string, array, etc.; and <code>napi_env</code>, which acts an anchor between Rust and Node.js.</p><p>You can use N-API functions to create any JavaScript value. For example, we used <code>napi_create_string_utf8</code> here to create a string. We passed in the environment a pointer to the string, the length of string, and a pointer to an empty memory location where it can write the pointer to the newly created value. All this code is unsafe because it includes many calls to external functions where the compiler cannot provide Rust guarantees. In the end, we returned the module that was provided to us by setting a property on it with the value <code>world!</code>.</p><p>Itâ€™s important to understand that <code>nodejs-sys</code> just provides the required definitions for the function youâ€™re using, not their implementation. N-API implementation is included with Node.js and you call it from your Rust code.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="using-the-addon-in-nodejs"></a>Using the addon in Node.js<a aria-hidden="true" tabindex="-1" class="hash-link" href="#using-the-addon-in-nodejs" title="Direct link to heading">#</a></h2><p>The next step is to add a linking configuration for different operating systems, then you can compile it.</p><p>Create a <code>build.rs</code> file to add a few configuration flags for linking the N-API files on different operating systems.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;cargo:rustc-cdylib-link-arg=-undefined&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    if cfg!(target_os = &quot;macos&quot;) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;cargo:rustc-cdylib-link-arg=dynamic_lookup&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p>Your directory should look like this:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ build.rs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ Cargo.lock</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ Cargo.toml</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ index.node</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ package.json</span></div><div class="token-line" style="color:#393A34"><span class="token plain">â”œâ”€â”€ src</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    â””â”€â”€ lib.rs</span></div></div></div></div></div><p>Now you need to compile your Rust addon. You can do so pretty easily using the simple command <code>cargo build --release</code>. This will take some time on the first run.</p><p>After your module is compiled, create a copy of this binary from <code>./target/release/libnative.so</code> to your root directory and rename it as <code>index.node</code>. The binary created by the cargo may have a different extension or name, depending on your crate setting and operating system.</p><p>Now you can require the file in Node.js and use it. You can also use it in a script. For example:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">let addon=require(&#x27;./index.node&#x27;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">console.log(addon.hello);</span></div></div></div></div></div><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/ozbxwwmm6680oz97v5ds.png" alt="Example"></p><p>Next, weâ€™ll move on to creating functions, arrays, and promises and using <code>libuv thread-pool</code> to perform heavy tasks without blocking the main thread.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="a-deep-dive-into-n-api"></a>A deep dive into N-API<a aria-hidden="true" tabindex="-1" class="hash-link" href="#a-deep-dive-into-n-api" title="Direct link to heading">#</a></h2><p>Now you know how to implement common patterns using N-API and Rust. A very common pattern is the export function, which can be called by the user of the library or Node module. Letâ€™s start by creating a function.</p><p>You should use <code>napi_create_function</code> to create your functions so that you can use them from Node.js. You can add these functions as a property to exports to use from Node.js.</p><p><strong>Creating a function</strong></p><p>JavaScript functions are also represented by the <code>napi_value</code> pointer. A N-API function is pretty easy to create and use.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">use nodejs_sys::{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_callback_info, napi_create_function, napi_create_string_utf8, napi_env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_set_named_property, napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">use std::ffi::CString;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn say_hello(env: napi_env, _info: napi_callback_info) -&gt; napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating  a javastring string</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let p = CString::new(&quot;Hello from rust&quot;).expect(&quot;CString::new    failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_string_utf8(env, p.as_ptr(), 13, &amp;mut local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// returning the javascript string</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    local</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">#[no_mangle]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn napi_register_module_v1(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    env: napi_env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports: napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">) -&gt; nodejs_sys::napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a C String</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let p = CString::new(&quot;myFunc&quot;).expect(&quot;CString::new failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a location where pointer to napi_value be written</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_function(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// pointer to function name</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        p.as_ptr(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// length of function name</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        5,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// rust function</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Some(say_hello),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// context which can be accessed by the rust function</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// output napi_value</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut local,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// set function as property</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_set_named_property(env, exports, p.as_ptr(), local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// returning exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/cfzmn20r0doiuhdgqaq3.png" alt="Example"></p><p>In the above example, we created a function in Rust named <code>say_hello</code>, which is executed when the JavaScript calls the function. We created a function using <code>napi_create_function</code>, which takes the following arguments:</p><ul><li>The <code>napi_env</code> value of the environment</li><li>A string for the function name which that be given to the JavaScript function</li><li>The length of the function name string</li><li>The function that is executed when the JavaScript calls the newly created function</li><li>Context data that can be passed by the user later and accessed from the Rust function</li><li>An empty memory address where the pointer to the JavaScript function can be saved</li><li>When you create this function, add it as a property to your <code>exports</code> object so that you can use it from JavaScript</li></ul><p>The function on the Rust side must have the same signature as shown in the example. Weâ€™ll discuss next how to access arguments inside a function using <code>napi_callback_info</code>. We can access this from a function and other arguments as well.</p><p><strong>Accessing</strong> <strong>arguments</strong></p><p>Function arguments are very important. N-API provides a method to access these arguments. <code>napi_callback_info</code> provides the pointer with detailed information about the function in the JavaScript side of the code.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">use nodejs_sys::{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_callback_info, napi_create_double, napi_create_function, napi_env, napi_get_cb_info,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_value_double, napi_set_named_property, napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">};</span></div><div class="token-line" style="color:#393A34"><span class="token plain">use std::ffi::CString;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn add(env: napi_env, info: napi_callback_info) -&gt; napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a buffer where napi_value of argument be written</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut buffer: [napi_value; 2] = std::mem::MaybeUninit::zeroed().assume_init();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// max number of arguments</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut argc = 2 as usize;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting arguments and value of this</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_cb_info(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        info,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut argc,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        buffer.as_mut_ptr(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// converting napi to f64</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut x = 0 as f64;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut y = 0 as f64;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_value_double(env, buffer[0], &amp;mut x);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_value_double(env, buffer[1], &amp;mut y);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating the return value</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_double(env, x + y, &amp;mut local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// returning the result</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    local</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">#[no_mangle]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn napi_register_module_v1(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    env: napi_env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports: napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">) -&gt; nodejs_sys::napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a function name</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let p = CString::new(&quot;myFunc&quot;).expect(&quot;CString::new failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating the function</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_function(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        p.as_ptr(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        5,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Some(add),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut local,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// setting function as property</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_set_named_property(env, exports, p.as_ptr(), local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// returning exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/u3r2j1xw1oh43jr8gygv.png" alt="Example"></p><p>Use <code>napi_get_cb_info</code> to get the arguments. The following arguments must be provided:</p><ul><li><code>napi_env</code></li><li>The info pointer</li><li>The number of expected arguments</li><li>A buffer where arguments can be written as <code>napi_value</code></li><li>A memory location to store metadata the user provided when JavaScript function was created</li><li>A memory location where this value pointer can be written</li></ul><p>We need to create an array with memory locations where C can write a pointer to arguments and we can pass this pointer buffer to N-API function. We also get <code>this</code>, but we arenâ€™t using it in this example.</p><p><strong>Working with strings arguments</strong></p><p>Most of the time, you need to work with strings in JavaScript. Both creating and getting the value of a string are pretty straightforward. Use <code>napi_get_value_string_utf8</code> and call this function twice: the first time to get length and second time to get the value of the string.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">use nodejs_sys::{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_callback_info, napi_create_function, napi_env, napi_get_cb_info, napi_get_undefined,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_value_string_utf8, napi_set_named_property, napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">};</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">use std::ffi::CString;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn print(env: napi_env, info: napi_callback_info) -&gt; napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a buffer of arguments</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut buffer: [napi_value; 1] = std::mem::MaybeUninit::zeroed().assume_init();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut argc = 1 as usize;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting arguments</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_cb_info(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        info,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut argc,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        buffer.as_mut_ptr(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut len = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting length by passing null buffer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_value_string_utf8(env, buffer[0], std::ptr::null_mut(), 0, &amp;mut len);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let size = len as usize;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a buffer where string can be placed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut ve: Vec&lt;u8&gt; = Vec::with_capacity(size + 1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let raw = ve.as_mut_ptr();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// telling rust not manage the vector</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    std::mem::forget(ve);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut cap = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting the string value from napi_value</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let _s = napi_get_value_string_utf8(env, buffer[0], raw as *mut i8, size + 1, &amp;mut cap);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from_raw_parts(raw, cap as usize, size);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// printing the string</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating an undefined</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut und: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_undefined(env, &amp;mut und);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// returning undefined</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    und</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">#[no_mangle]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn napi_register_module_v1(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    env: napi_env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports: napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">) -&gt; nodejs_sys::napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let p = CString::new(&quot;myFunc&quot;).expect(&quot;CString::new failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_function(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        p.as_ptr(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        5,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Some(print),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut local,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_set_named_property(env, exports, p.as_ptr(), local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/zbk15csxak95qvnd2tcg.png" alt="Example"></p><p>Youâ€™ll need to pass a few arguments to <code>napi_create_string_utf8</code> to create a string. If a null pointer is passed as buffer, the length of the string is given. The following arguments are required:</p><ul><li><code>napi_env</code></li><li><code>napi_value</code> pointer to the string in <code>javascript side</code></li><li>The buffer where the string is to be written if null gives the length of the string</li><li>The length of the buffer</li><li>Bytes written to the buffer</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="working-with-promises-and-libuv-thread-pool"></a>Working with promises and libuv thread pool<a aria-hidden="true" tabindex="-1" class="hash-link" href="#working-with-promises-and-libuv-thread-pool" title="Direct link to heading">#</a></h2><p>Itâ€™s not a good idea to block the main thread of Node.js for doing calculations. You can use libuv threads to do the heavy lifting.</p><p>First, create a promise. The promise will reject or resolve based on the success of your work. For this, youâ€™ll need to create three functions. The first one is called from the JavaScript world and the control would be passed to the second function, which runs on libuv thread and has no access to JavaScript. The third function, which does have access to the JavaScript side, is called after the second finishes. You can use the <code>napi_create_async_work</code> method for the libuv thread.</p><p><strong>Creating a promise</strong></p><p>To create a promise, simply use <code>napi_create_promise</code>. This will provide a pointer, <code>napi_deferred</code>, which can then resolve or reject a promise using the following functions:</p><ul><li><code>napi_resolve_deferred</code></li><li><code>napi_reject_deferred</code></li></ul><p><strong>Error handling</strong></p><p>You can create and throw an error from the Rust code using <code>napi_create_error</code> and <code>napi_throw_error</code>. Every N-API function returns a <code>napi_status</code>, which should be checked.</p><p><strong>Real code</strong></p><p>The following example shows how to schedule async work.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-rust codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">    use nodejs_sys::{</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_async_work, napi_callback_info, napi_create_async_work, napi_create_error,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_create_function, napi_create_int64, napi_create_promise, napi_create_string_utf8,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_deferred, napi_delete_async_work, napi_env, napi_get_cb_info, napi_get_value_int64,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_queue_async_work, napi_reject_deferred, napi_resolve_deferred, napi_set_named_property,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_status, napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    };</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use std::ffi::c_void;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    use std::ffi::CString;</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug, Clone)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    struct Data {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        deferred: napi_deferred,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        work: napi_async_work,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        val: u64,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        result: Option&lt;Result&lt;u64, String&gt;&gt;,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub unsafe extern &quot;C&quot; fn feb(env: napi_env, info: napi_callback_info) -&gt; napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut buffer: Vec&lt;napi_value&gt; = Vec::with_capacity(1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let p = buffer.as_mut_ptr();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut argc = 1 as usize;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::mem::forget(buffer);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_get_cb_info(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            info,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            &amp;mut argc,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            p,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut start = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_get_value_int64(env, *p, &amp;mut start);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut promise: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut deferred: napi_deferred = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut work_name: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut work: napi_async_work = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let async_name = CString::new(&quot;async fibonaci&quot;).expect(&quot;Error creating string&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_create_string_utf8(env, async_name.as_ptr(), 13, &amp;mut work_name);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_create_promise(env, &amp;mut deferred, &amp;mut promise);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let v = Data {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            deferred,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            work,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            val: start as u64,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            result: None,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        };</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let data = Box::new(v);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let raw = Box::into_raw(data);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_create_async_work(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            work_name,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Some(perform),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Some(complete),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            std::mem::transmute(raw),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            &amp;mut work,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_queue_async_work(env, work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (*raw).work = work;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        promise</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub unsafe extern &quot;C&quot; fn perform(_env: napi_env, data: *mut c_void) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut last = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut second_last = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        for _ in 2..t.val {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let temp = last;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            last = last + second_last;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            second_last = temp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        t.result = Some(Ok(last));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Box::into_raw(task);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub unsafe extern &quot;C&quot; fn complete(env: napi_env, _status: napi_status, data: *mut c_void) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let v = match t.result {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Some(d) =&gt; match d {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Ok(result) =&gt; result,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Err(_) =&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    let mut js_error: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    napi_create_error(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        &amp;mut js_error,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    napi_reject_deferred(env, t.deferred, js_error);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    napi_delete_async_work(env, t.work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            None =&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                let mut js_error: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                napi_create_error(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    &amp;mut js_error,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                napi_reject_deferred(env, t.deferred, js_error);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                napi_delete_async_work(env, t.work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        };</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut obj: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_create_int64(env, v as i64, &amp;mut obj);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_resolve_deferred(env, t.deferred, obj);</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_delete_async_work(env, t.work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    #[no_mangle]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pub unsafe extern &quot;C&quot; fn napi_register_module_v1(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env: napi_env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        exports: napi_value,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ) -&gt; nodejs_sys::napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let p = CString::new(&quot;myFunc&quot;).expect(&quot;CString::new failed&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let mut local: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_create_function(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            p.as_ptr(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            5,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Some(feb),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            &amp;mut local,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        napi_set_named_property(env, exports, p.as_ptr(), local);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        exports</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div></div></div></div></div><p>We created a struct to store a pointer to our <code>napi_async_work</code> and <code>napi_deferred</code> as well as our output. Initially, the output is <code>None</code>. Then we created a promise, which provides a <code>deferred</code> that we save in our data. This data is available to us in all of our functions. Next, we converted our data into raw data and pass it to the <code>napi_create_async_work</code> function with other callbacks. We returned the promise we created, executed <code>perform</code>, and converted our data back to struct. Once <code>perform</code> is completed on libuv thread, <code>complete</code> is called from the main thread, along with the status of the previous operation and our data. Now we can reject or resolve our work and delete work from the queue.</p><p><strong>Lets walk through the code</strong></p><p>Create a function called <code>feb</code>, which will be exported to JavaScript. This function will return a promise and schedule work for the libuv thread pool. You can achieve this by creating a promise, using <code>napi_create_async_work</code>, and passing two functions to it. One is executed on the libuv thread and the other on the main thread. Since you can only execute JavaScript from the main thread, you must resolve or reject a promise only from the main thread. The code includes a large number of unsafe functions.</p><p><strong><code>feb</code> function</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn feb(env: napi_env, info: napi_callback_info) -&gt; napi_value {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut buffer: Vec&lt;napi_value&gt; = Vec::with_capacity(1);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let p = buffer.as_mut_ptr();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut argc = 1 as usize;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    std::mem::forget(buffer);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting arguments for the function</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_cb_info(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        info,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut argc,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        p,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut start = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// converting the napi_value to u64 number</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_get_value_int64(env, *p, &amp;mut start);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// promise which would be returned</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut promise: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// a pointer to promise to resolve is or reject it</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut deferred: napi_deferred = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// a pointer to our async work name used for debugging</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut work_name: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// pointer to async work</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut work: napi_async_work = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let async_name = CString::new(&quot;async fibonaci&quot;).expect(&quot;Error creating string&quot;);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a string for name</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_string_utf8(env, async_name.as_ptr(), 13, &amp;mut work_name);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a promise</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_promise(env, &amp;mut deferred, &amp;mut promise);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let v = Data {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        deferred,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        work,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        val: start as u64,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        result: None,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    };</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating a context which can be saved to share state between our functions</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let data = Box::new(v);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// converting it to raw pointer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let raw = Box::into_raw(data);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating the work</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_async_work(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        work_name,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Some(perform),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Some(complete),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        std::mem::transmute(raw),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        &amp;mut work,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// queuing to execute the work</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_queue_async_work(env, work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// setting pointer to work that can be used later</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    (*raw).work = work;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// retuning the pormise</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    promise</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p><strong><code>perform</code> function</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn perform(_env: napi_env, data: *mut c_void) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting the shared data and converting the in box</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut last = 1;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut second_last = 0;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    for _ in 2..t.val {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let temp = last;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        last = last + second_last;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        second_last = temp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// setting the result on shared context</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    t.result = Some(Ok(last));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// telling the rust to not to drop the context data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    Box::into_raw(t);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><p><strong><code>complete</code> Function</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">pub unsafe extern &quot;C&quot; fn complete(env: napi_env, _status: napi_status, data: *mut c_void) {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// getting the shared context</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let t: Box&lt;Data&gt; = Box::from_raw(std::mem::transmute(data));</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let v = match task.result {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Some(d) =&gt; match d {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Ok(result) =&gt; result,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Err(_) =&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// if there is error just throw an error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                let mut js_error: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                napi_create_error(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    &amp;mut js_error,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// rejecting the promise with error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                napi_reject_deferred(env, task.deferred, js_error);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// deleting the task from the queue</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                napi_delete_async_work(env, task.work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        },</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; {</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// if no result is found reject with error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating an error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let mut js_error: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            napi_create_error(</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                env,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                std::ptr::null_mut(),</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                &amp;mut js_error,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            );</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// rejecting promise with error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            napi_reject_deferred(env, task.deferred, js_error);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// deleting the task from queue</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            napi_delete_async_work(env, task.work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            return;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    };</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// creating the number</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let mut obj: napi_value = std::mem::zeroed();</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_create_int64(env, v as i64, &amp;mut obj);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// resolving the promise with result</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_resolve_deferred(env, t.deferred, obj);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">// deleting the work</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    napi_delete_async_work(env, t.work);</span></div><div class="token-line" style="color:#393A34"><span class="token plain">}</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="conclusion"></a>Conclusion<a aria-hidden="true" tabindex="-1" class="hash-link" href="#conclusion" title="Direct link to heading">#</a></h2><p>This is just the tip of the iceberg when it comes to what you can do with N-API. We went over a few patterns and covered the basics, such as how to export function, create oft-used JavaScript types such as strings, numbers, arrays, objects, etc., get the context of a function (i.e., get the arguments and <code>this</code> in a function), etc.</p><p>We also examined an in-depth example of how to use <code>libuv</code> threads and create an <code>async_work</code> to perform heavy calculations in the background. Finally, we created and used JavaScript&#x27;s promises and learned how to do error handling in N-APIs.</p><p>There are many libraries available if you donâ€™t want to write all the code by hand. These provide nice abstractions, but the downside is that they don&#x27;t support all features.</p><ul><li><a href="https://github.com/neon-bindings/neon" target="_blank" rel="noopener noreferrer">noen</a></li><li><a href="https://github.com/infinyon/node-bindgen" target="_blank" rel="noopener noreferrer">node-bindgen</a></li><li><a href="https://github.com/Brooooooklyn/napi-rs" target="_blank" rel="noopener noreferrer">napi-rs</a></li></ul></section><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/rust">rust</a><a class="margin-horiz--sm" href="/blog/tags/nodejs">nodejs</a></div></footer></article><div></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/grpc-rust"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Â« A beginners guide to gRPC with Rust</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/react-formik"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Creating Forms In React With Formik And Yup Â»</div></a></div></nav></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">About</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/resume">Resume</a></li><li class="footer__item"><a class="footer__link-item" href="/projects">Contributions</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://dev.to/jatinarora1" target="_blank" rel="noopener noreferrer" class="footer__link-item">Dev.to</a></li><li class="footer__item"><a href="https://medium.com/@arora8331" target="_blank" rel="noopener noreferrer" class="footer__link-item">Medium</a></li><li class="footer__item"><a href="https://www.linkedin.com/in/jatin-a-5a3286137/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Linkedin</a></li><li class="footer__item"><a href="https://twitter.com/JATINAR27664823" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/anshulrgoyal" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright Â© 2020 Jatin Arora.</div></div></div></footer></div>
<script src="/styles.152560a6.js"></script>
<script src="/runtime~main.b8677e71.js"></script>
<script src="/main.48060fb2.js"></script>
<script src="/1.57e2cf85.js"></script>
<script src="/2.818658f0.js"></script>
<script src="/3.d3fc3d6d.js"></script>
<script src="/ccc49370.2475dd98.js"></script>
<script src="/13288dd4.611b1975.js"></script>
</body>
</html>